# POKERTOOL-HEADER-START
# ---
# schema: pokerheader.v1
# project: pokertool
# file: src/pokertool/tournament_support.py
# version: v28.0.0
# last_commit: '2025-09-23T08:41:38+01:00'
# fixes:
# - date: '2025-09-25'
#   summary: Enhanced enterprise documentation and comprehensive unit tests added
# ---
# POKERTOOL-HEADER-END
"""
Tournament Support Module
Provides comprehensive tournament poker features including ICM calculations,
bubble factor analysis, push/fold charts, and tournament-specific strategy.
"""

import logging
import math
from typing import Dict, Any, List, Optional, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
import itertools

logger = logging.getLogger(__name__)

class TournamentPhase(Enum):
    """Different phases of tournament play."""
    EARLY = "early"
    MIDDLE = "middle" 
    BUBBLE = "bubble"
    IN_THE_MONEY = "in_the_money"
    FINAL_TABLE = "final_table"
    HEADS_UP = "heads_up"

class TournamentType(Enum):
    """Types of tournaments."""
    FREEZE_OUT = "freeze_out"
    REBUY = "rebuy"
    ADD_ON = "add_on"
    TURBO = "turbo"
    HYPER_TURBO = "hyper_turbo"
    SATELLITE = "satellite"
    SIT_N_GO = "sit_n_go"
    SPIN_N_GO = "spin_n_go"
    KNOCKOUT = "knockout"
    PROGRESSIVE_KNOCKOUT = "progressive_knockout"

@dataclass
class TournamentStructure:
    """Tournament structure information."""
    buy_in: float
    fee: float
    starting_chips: int
    blind_levels: List[Tuple[int, int]]  # (small_blind, big_blind)
    level_duration: int  # minutes
    ante_start_level: int = 0
    antes: List[int] = field(default_factory=list)
    tournament_type: TournamentType = TournamentType.FREEZE_OUT

@dataclass
class PayoutStructure:
    """Tournament payout structure."""
    total_entries: int
    total_prize_pool: float
    payouts: List[float]  # Ordered from 1st place down
    bubble_position: int  # Last position that doesn't cash
    
    def get_payout_percentage(self, position: int) -> float:
        """Get payout as percentage of prize pool."""
        if position > len(self.payouts) or position < 1:
            return 0.0
        return self.payouts[position - 1] / self.total_prize_pool

@dataclass
class PlayerStack:
    """Individual player's tournament stack."""
    player_id: str
    chips: int
    position: int  # Seat position
    is_active: bool = True

@dataclass
class TournamentState:
    """Current state of tournament."""
    total_players: int
    players_remaining: int
    current_level: int
    small_blind: int
    big_blind: int
    ante: int = 0
    players: List[PlayerStack] = field(default_factory=list)
    average_stack: float = 0.0
    time_left_in_level: int = 0  # seconds
    
    def update_average_stack(self):
        """Update average stack size."""
        if self.players:
            total_chips = sum(p.chips for p in self.players if p.is_active)
            active_players = sum(1 for p in self.players if p.is_active)
            self.average_stack = total_chips / active_players if active_players > 0 else 0

class ICMCalculator:
    """Independent Chip Model calculator for tournament equity."""
    
    @staticmethod
    def calculate_icm_equity(stacks: List[int], payouts: List[float]) -> List[float]:
        """
        Calculate ICM equity for each player.
        
        Args:
            stacks: List of chip stacks
            payouts: List of prize amounts (ordered from 1st to last paid position)
            
        Returns:
            List of ICM equity values for each player
        """
        if not stacks or not payouts or len(stacks) < 2:
            return [0.0] * len(stacks)
        
        num_players = len(stacks)
        num_paid_positions = len(payouts)
        
        if num_players <= num_paid_positions:
            # Everyone is in the money, distribute based on chip percentage
            total_chips = sum(stacks)
            total_prize_pool = sum(payouts)
            return [(stack / total_chips) * total_prize_pool for stack in stacks]
        
        # Calculate elimination probabilities
        total_chips = sum(stacks)
        equities = [0.0] * num_players
        
        # Use recursive calculation for ICM
        for i in range(num_players):
            equities[i] = ICMCalculator._calculate_player_equity(
                i, stacks, payouts, total_chips
            )
        
        return equities
    
    @staticmethod
    def _calculate_player_equity(player_index: int, stacks: List[int], 
                                payouts: List[float], total_chips: int) -> float:
        """Calculate equity for a specific player using recursive ICM."""
        if not payouts:
            return 0.0
        
        if len(stacks) <= len(payouts):
            # Everyone remaining gets paid
            return (stacks[player_index] / total_chips) * sum(payouts)
        
        # Calculate probability of each other player being eliminated
        equity = 0.0
        player_stack = stacks[player_index]
        
        for i, other_stack in enumerate(stacks):
            if i == player_index:
                continue
                
            # Probability that player i gets eliminated
            elimination_prob = other_stack / total_chips
            
            # Create new stacks list without eliminated player
            new_stacks = [s for j, s in enumerate(stacks) if j != i]
            new_total = total_chips - other_stack
            
            # Recursive call with remaining players and payouts
            remaining_equity = ICMCalculator._calculate_player_equity(
                player_index if player_index < i else player_index - 1,
                new_stacks, payouts, new_total
            )
            
            equity += elimination_prob * remaining_equity
        
        return equity
    
    @staticmethod
    def calculate_bubble_factor(stacks: List[int], payouts: List[float], 
                               player_index: int) -> float:
        """
        Calculate bubble factor for a player.
        Bubble factor = (chip value in chips) / (chip value in dollars)
        """
        if player_index >= len(stacks):
            return 1.0
        
        current_equity = ICMCalculator.calculate_icm_equity(stacks, payouts)[player_index]
        
        # Calculate equity if player had one more chip
        test_stacks = stacks.copy()
        test_stacks[player_index] += 1
        new_equity = ICMCalculator.calculate_icm_equity(test_stacks, payouts)[player_index]
        
        chip_value_dollars = new_equity - current_equity
        chip_value_chips = 1.0 / sum(stacks)  # Proportional chip value
        
        if chip_value_dollars <= 0:
            return float('inf')  # Infinite bubble factor
        
        return chip_value_chips / chip_value_dollars

class PushFoldCalculator:
    """Calculate optimal push/fold ranges for tournament play."""
    
    @staticmethod
    def calculate_push_range(effective_stack: float, players_to_act: int,
                           bubble_factor: float = 1.0) -> float:
        """
        Calculate push range based on effective stack and bubble factor.
        
        Args:
            effective_stack: Stack size in big blinds
            players_to_act: Number of players yet to act
            bubble_factor: ICM bubble factor adjustment
            
        Returns:
            Percentage of hands to push (0-1)
        """
        if effective_stack <= 0:
            return 0.0
        
        # Base push range calculation (simplified Nash equilibrium approximation)
        if effective_stack >= 20:
            base_range = 0.15  # 15% of hands
        elif effective_stack >= 15:
            base_range = 0.20  # 20% of hands
        elif effective_stack >= 10:
            base_range = 0.35  # 35% of hands  
        elif effective_stack >= 7:
            base_range = 0.50  # 50% of hands
        elif effective_stack >= 5:
            base_range = 0.65  # 65% of hands
        else:
            base_range = min(1.0, 0.8 + (5 - effective_stack) * 0.05)  # Very wide
        
        # Adjust for number of players to act
        player_adjustment = 1.0 - (players_to_act - 1) * 0.1
        player_adjustment = max(0.3, player_adjustment)  # Don't go below 30%
        
        # Adjust for bubble factor
        bubble_adjustment = 1.0 / bubble_factor if bubble_factor > 1 else 1.0
        bubble_adjustment = max(0.5, bubble_adjustment)  # Don't be too tight
        
        adjusted_range = base_range * player_adjustment * bubble_adjustment
        return min(1.0, max(0.0, adjusted_range))
    
    @staticmethod
    def calculate_call_range(pot_odds: float, effective_stack: float,
                           bubble_factor: float = 1.0) -> float:
        """Calculate calling range against a push."""
        if effective_stack <= 0 or pot_odds <= 0:
            return 0.0
        
        # Base calling range based on pot odds
        if pot_odds >= 2.0:  # Getting 2:1 or better
            base_range = 0.25  # 25% of hands
        elif pot_odds >= 1.5:
            base_range = 0.15  # 15% of hands
        elif pot_odds >= 1.2:
            base_range = 0.10  # 10% of hands
        else:
            base_range = 0.05  # 5% of hands (very strong only)
        
        # Adjust for stack depth
        stack_adjustment = min(1.5, effective_stack / 10.0)
        
        # Adjust for bubble factor (tighter when bubble factor is high)
        bubble_adjustment = 1.0 / bubble_factor if bubble_factor > 1 else 1.0
        
        adjusted_range = base_range * stack_adjustment * bubble_adjustment
        return min(1.0, max(0.0, adjusted_range))

class TournamentStrategy:
    """Tournament-specific strategy calculations."""
    
    @staticmethod
    def determine_tournament_phase(players_remaining: int, total_players: int,
                                 bubble_position: int) -> TournamentPhase:
        """Determine current tournament phase."""
        percentage_remaining = players_remaining / total_players
        
        if players_remaining == 2:
            return TournamentPhase.HEADS_UP
        elif players_remaining <= 9:
            return TournamentPhase.FINAL_TABLE
        elif players_remaining <= bubble_position + 2:
            return TournamentPhase.BUBBLE
        elif players_remaining <= bubble_position * 1.5:
            return TournamentPhase.IN_THE_MONEY
        elif percentage_remaining <= 0.3:
            return TournamentPhase.MIDDLE
        else:
            return TournamentPhase.EARLY
    
    @staticmethod
    def calculate_m_ratio(stack: int, small_blind: int, big_blind: int, ante: int = 0) -> float:
        """Calculate M-ratio (Harrington's M)."""
        orbit_cost = small_blind + big_blind + (ante * 9)  # Assuming 9-handed
        if orbit_cost <= 0:
            return float('inf')
        return stack / orbit_cost
    
    @staticmethod
    def get_strategy_recommendation(m_ratio: float, phase: TournamentPhase,
                                  bubble_factor: float = 1.0) -> Dict[str, Any]:
        """Get strategy recommendation based on M-ratio and tournament phase."""
        recommendations = {
            'playing_style': '',
            'aggression_level': 0.0,  # 0-1 scale
            'range_adjustment': 1.0,  # Multiplier for standard ranges
            'key_focuses': [],
            'warnings': []
        }
        
        # Base recommendations on M-ratio
        if m_ratio >= 20:
            recommendations['playing_style'] = 'Deep stack play'
            recommendations['aggression_level'] = 0.6
            recommendations['key_focuses'] = ['Post-flop play', 'Value betting', 'Bluffing']
        elif m_ratio >= 10:
            recommendations['playing_style'] = 'Standard tournament play'
            recommendations['aggression_level'] = 0.7
            recommendations['key_focuses'] = ['Selective aggression', 'Position play']
        elif m_ratio >= 6:
            recommendations['playing_style'] = 'Push-fold considerations'
            recommendations['aggression_level'] = 0.8
            recommendations['key_focuses'] = ['Pre-flop aggression', 'Fold equity']
            recommendations['warnings'] = ['Avoid marginal spots']
        elif m_ratio >= 3:
            recommendations['playing_style'] = 'Short stack play'
            recommendations['aggression_level'] = 0.9
            recommendations['key_focuses'] = ['Push-fold strategy', 'Chip preservation']
            recommendations['warnings'] = ['Very limited post-flop play']
        else:
            recommendations['playing_style'] = 'Push-fold only'
            recommendations['aggression_level'] = 1.0
            recommendations['key_focuses'] = ['All-in or fold']
            recommendations['warnings'] = ['Desperate situation', 'Need to double up']
        
        # Adjust for tournament phase
        if phase == TournamentPhase.BUBBLE:
            recommendations['aggression_level'] *= 0.7  # Tighter on bubble
            recommendations['range_adjustment'] *= bubble_factor
            recommendations['key_focuses'].append('ICM considerations')
            if bubble_factor > 2.0:
                recommendations['warnings'].append('High bubble pressure')
        elif phase == TournamentPhase.FINAL_TABLE:
            recommendations['key_focuses'].append('Pay jump awareness')
            recommendations['warnings'].append('Every decision matters')
        elif phase == TournamentPhase.EARLY:
            recommendations['aggression_level'] *= 0.8  # More conservative early
            recommendations['key_focuses'].append('Chip accumulation')
        
        return recommendations
    
    @staticmethod
    def calculate_satellite_strategy(tickets_awarded: int, players_remaining: int,
                                   min_stack_to_win: int, current_stack: int) -> Dict[str, Any]:
        """Calculate strategy for satellite tournaments."""
        if players_remaining <= tickets_awarded:
            return {
                'strategy': 'SURVIVAL_MODE',
                'recommendation': 'Fold everything except premium hands',
                'aggression_level': 0.1,
                'key_focus': 'Avoid elimination at all costs'
            }
        
        # Calculate if we're in contention for a ticket
        survival_ratio = current_stack / min_stack_to_win if min_stack_to_win > 0 else 0
        
        if survival_ratio >= 1.5:
            return {
                'strategy': 'COMFORTABLE',
                'recommendation': 'Play normally but avoid huge pots with mid-strength hands',
                'aggression_level': 0.6,
                'key_focus': 'Maintain comfortable stack'
            }
        elif survival_ratio >= 1.0:
            return {
                'strategy': 'CAUTIOUS',
                'recommendation': 'Tighten up, avoid marginal spots',
                'aggression_level': 0.4,
                'key_focus': 'Preserve ticket-winning stack'
            }
        elif survival_ratio >= 0.7:
            return {
                'strategy': 'BORDERLINE',
                'recommendation': 'Selective aggression to build stack',
                'aggression_level': 0.7,
                'key_focus': 'Need to accumulate chips carefully'
            }
        else:
            return {
                'strategy': 'DESPERATE',
                'recommendation': 'Must double up - take calculated risks',
                'aggression_level': 0.9,
                'key_focus': 'High risk, high reward plays needed'
            }

class TournamentAnalyzer:
    """Comprehensive tournament analysis system."""
    
    def __init__(self):
        self.icm_calculator = ICMCalculator()
        self.push_fold_calculator = PushFoldCalculator()
        self.strategy_engine = TournamentStrategy()
    
    def analyze_tournament_spot(self, tournament_state: TournamentState,
                              payout_structure: PayoutStructure,
                              hero_player_id: str) -> Dict[str, Any]:
        """Comprehensive analysis of current tournament situation."""
        # Find hero player
        hero_player = None
        hero_index = -1
        for i, player in enumerate(tournament_state.players):
            if player.player_id == hero_player_id:
                hero_player = player
                hero_index = i
                break
        
        if not hero_player:
            return {'error': 'Hero player not found'}
        
        # Calculate basic metrics
        effective_stack = hero_player.chips / tournament_state.big_blind
        m_ratio = TournamentStrategy.calculate_m_ratio(
            hero_player.chips, 
            tournament_state.small_blind, 
            tournament_state.big_blind,
            tournament_state.ante
        )
        
        # Determine tournament phase
        phase = TournamentStrategy.determine_tournament_phase(
            tournament_state.players_remaining,
            tournament_state.total_players,
            payout_structure.bubble_position
        )
        
        # Calculate ICM equity
        stacks = [p.chips for p in tournament_state.players if p.is_active]
        icm_equities = self.icm_calculator.calculate_icm_equity(stacks, payout_structure.payouts)
        hero_icm_equity = icm_equities[hero_index] if hero_index < len(icm_equities) else 0.0
        
        # Calculate bubble factor
        bubble_factor = self.icm_calculator.calculate_bubble_factor(
            stacks, payout_structure.payouts, hero_index
        ) if hero_index < len(stacks) else 1.0
        
        # Get strategy recommendations
        strategy_rec = TournamentStrategy.get_strategy_recommendation(
            m_ratio, phase, bubble_factor
        )
        
        # Calculate push/fold ranges
        push_range = self.push_fold_calculator.calculate_push_range(
            effective_stack, len([p for p in tournament_state.players if p.is_active]) - 1, bubble_factor
        )
        
        return {
            'hero_stack': hero_player.chips,
            'effective_stack_bb': effective_stack,
            'm_ratio': m_ratio,
            'tournament_phase': phase.value,
            'icm_equity': hero_icm_equity,
            'icm_equity_percentage': (hero_icm_equity / payout_structure.total_prize_pool) * 100,
            'bubble_factor': bubble_factor,
            'push_range_percentage': push_range * 100,
            'strategy_recommendation': strategy_rec,
            'players_remaining': tournament_state.players_remaining,
            'average_stack': tournament_state.average_stack,
            'stack_relative_to_average': hero_player.chips / tournament_state.average_stack if tournament_state.average_stack > 0 else 0,
            'blinds_info': {
                'small_blind': tournament_state.small_blind,
                'big_blind': tournament_state.big_blind,
                'ante': tournament_state.ante,
                'level': tournament_state.current_level
            }
        }
    
    def generate_push_fold_chart(self, effective_stacks: List[float], 
                                positions: List[int], bubble_factor: float = 1.0) -> Dict[str, List[float]]:
        """Generate push/fold chart for different stack sizes and positions."""
        chart = {}
        
        for stack in effective_stacks:
            stack_ranges = []
            for pos in positions:
                players_behind = max(0, 9 - pos)  # Assuming 9-handed table
                push_range = self.push_fold_calculator.calculate_push_range(
                    stack, players_behind, bubble_factor
                )
                stack_ranges.append(push_range * 100)  # Convert to percentage
            
            chart[f'{stack}bb'] = stack_ranges
        
        return chart

# Global tournament analyzer
_tournament_analyzer: Optional[TournamentAnalyzer] = None

def get_tournament_analyzer() -> TournamentAnalyzer:
    """Get the global tournament analyzer instance."""
    global _tournament_analyzer
    if _tournament_analyzer is None:
        _tournament_analyzer = TournamentAnalyzer()
    return _tournament_analyzer

def calculate_icm_equity(stacks: List[int], payouts: List[float]) -> List[float]:
    """Calculate ICM equity for tournament situation."""
    return ICMCalculator.calculate_icm_equity(stacks, payouts)

def get_tournament_strategy(stack_bb: float, m_ratio: float, phase: str, 
                          bubble_factor: float = 1.0) -> Dict[str, Any]:
    """Get tournament strategy recommendation."""
    phase_enum = TournamentPhase(phase)
    return TournamentStrategy.get_strategy_recommendation(m_ratio, phase_enum, bubble_factor)

def analyze_satellite_spot(tickets: int, players_left: int, min_stack: int, 
                         current_stack: int) -> Dict[str, Any]:
    """Analyze satellite tournament situation."""
    return TournamentStrategy.calculate_satellite_strategy(
        tickets, players_left, min_stack, current_stack
    )

if __name__ == '__main__':
    # Test tournament support system
    analyzer = get_tournament_analyzer()
    
    # Create test tournament state
    players = [
        PlayerStack("player1", 15000, 1),  # Hero
        PlayerStack("player2", 12000, 2),
        PlayerStack("player3", 8000, 3),
        PlayerStack("player4", 25000, 4),
        PlayerStack("player5", 5000, 5),
    ]
    
    tournament_state = TournamentState(
        total_players=100,
        players_remaining=5,
        current_level=8,
        small_blind=500,
        big_blind=1000,
        ante=100,
        players=players
    )
    tournament_state.update_average_stack()
    
    # Create payout structure
    payouts = [10000, 6000, 4000, 2500, 1500]  # Top 5 paid
    payout_structure = PayoutStructure(
        total_entries=100,
        total_prize_pool=25000,
        payouts=payouts,
        bubble_position=95
    )
    
    # Analyze tournament spot
    analysis = analyzer.analyze_tournament_spot(tournament_state, payout_structure, "player1")
    
    logger.info("Tournament Analysis Results:")
    logger.info(f"Hero stack: {analysis['hero_stack']} chips ({analysis['effective_stack_bb']:.1f} BB)")
    logger.info(f"M-ratio: {analysis['m_ratio']:.1f}")
    logger.info(f"Tournament phase: {analysis['tournament_phase']}")
    logger.info(f"ICM equity: ${analysis['icm_equity']:.2f} ({analysis['icm_equity_percentage']:.1f}%)")
    logger.info(f"Bubble factor: {analysis['bubble_factor']:.2f}")
    logger.info(f"Push range: {analysis['push_range_percentage']:.1f}% of hands")
    
    strategy = analysis['strategy_recommendation']
    logger.info(f"Strategy: {strategy['playing_style']}")
    logger.info(f"Aggression level: {strategy['aggression_level']:.1f}/1.0")
    logger.info(f"Key focuses: {', '.join(strategy['key_focuses'])}")
    if strategy['warnings']:
        logger.info(f"Warnings: {', '.join(strategy['warnings'])}")
    
    # Test ICM calculation
    stacks = [p.chips for p in players]
    icm_equities = calculate_icm_equity(stacks, payouts)
    logger.info("ICM Equities:")
    for i, equity in enumerate(icm_equities):
        logger.info(f"Player {i+1}: ${equity:.2f}")
    
    # Test push/fold chart generation
    push_fold_chart = analyzer.generate_push_fold_chart(
        effective_stacks=[5, 8, 12, 15, 20],
        positions=[1, 3, 6, 9],
        bubble_factor=2.0
    )
    logger.info("Push/Fold Chart (Bubble Factor 2.0):")
    for stack, ranges in push_fold_chart.items():
        logger.info(f"{stack}: {ranges}")
    
    logger.info("Tournament support system test completed!")
