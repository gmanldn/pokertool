"""
Exploitative Strategy Engine

Adjusts GTO recommendations based on opponent tendencies to maximize EV.
"""
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
import logging
from pokertool.smarthelper_engine import PokerAction, GameState, DecisionFactor
from pokertool.opponent_profiler import OpponentStats, PlayerType, OpponentProfiler

logger = logging.getLogger(__name__)


@dataclass
class ExploitativeAdjustment:
    """Adjustment to GTO strategy"""
    adjustment_type: str
    description: str
    ev_gain: float  # Expected EV gain from exploitation
    risk_level: str  # LOW, MEDIUM, HIGH


class ExploitativeEngine:
    """Generates exploitative strategy adjustments"""

    def __init__(self):
        self.profiler = OpponentProfiler()

    def get_exploitative_action(
        self,
        gto_action: PokerAction,
        gto_amount: Optional[float],
        game_state: GameState,
        opponent_stats: OpponentStats
    ) -> Tuple[PokerAction, Optional[float], List[ExploitativeAdjustment]]:
        """
        Adjust GTO action to exploit opponent tendencies

        Args:
            gto_action: GTO recommended action
            gto_amount: GTO bet/raise amount
            game_state: Current game state
            opponent_stats: Opponent statistics

        Returns:
            Tuple of (exploitative_action, amount, adjustments_list)
        """
        adjustments = []
        exploitative_action = gto_action
        exploitative_amount = gto_amount

        # Classify opponent
        player_type = self.profiler.classify_player_type(opponent_stats)

        # Apply tightness/looseness adjustments
        tight_loose_adj = self._adjust_for_tightness(
            gto_action, gto_amount, opponent_stats, game_state
        )
        if tight_loose_adj:
            adjustments.append(tight_loose_adj)
            if tight_loose_adj.adjustment_type == "INCREASE_AGGRESSION":
                if gto_action == PokerAction.CALL:
                    exploitative_action = PokerAction.RAISE
                    exploitative_amount = game_state.bet_to_call * 2.5

        # Apply aggression adjustments
        agg_adj = self._adjust_for_aggression(
            gto_action, gto_amount, opponent_stats, game_state
        )
        if agg_adj:
            adjustments.append(agg_adj)

        # Apply fold tendency adjustments
        fold_adj = self._adjust_for_fold_tendency(
            gto_action, gto_amount, opponent_stats, game_state
        )
        if fold_adj:
            adjustments.append(fold_adj)
            if fold_adj.adjustment_type == "INCREASE_BLUFF_FREQUENCY":
                # Bluff more against folders
                if gto_action == PokerAction.CHECK and game_state.bet_to_call == 0:
                    exploitative_action = PokerAction.BET
                    exploitative_amount = game_state.pot_size * 0.66

        logger.info(
            f"Exploitative adjustments: {len(adjustments)} adjustments "
            f"({gto_action.value} â†’ {exploitative_action.value})"
        )

        return exploitative_action, exploitative_amount, adjustments

    def _adjust_for_tightness(
        self,
        action: PokerAction,
        amount: Optional[float],
        stats: OpponentStats,
        game_state: GameState
    ) -> Optional[ExploitativeAdjustment]:
        """Adjust for tight/loose opponents"""

        # Loose opponent (VPIP > 35%)
        if stats.vpip > 35:
            if action in [PokerAction.BET, PokerAction.RAISE]:
                return ExploitativeAdjustment(
                    adjustment_type="TIGHTEN_VALUE_RANGE",
                    description="Opponent plays too many hands - tighten value range",
                    ev_gain=0.15,
                    risk_level="LOW"
                )

        # Tight opponent (VPIP < 20%)
        elif stats.vpip < 20:
            if action == PokerAction.CALL and game_state.bet_to_call > 0:
                return ExploitativeAdjustment(
                    adjustment_type="INCREASE_AGGRESSION",
                    description="Opponent is tight - raise instead of call",
                    ev_gain=0.25,
                    risk_level="MEDIUM"
                )

        return None

    def _adjust_for_aggression(
        self,
        action: PokerAction,
        amount: Optional[float],
        stats: OpponentStats,
        game_state: GameState
    ) -> Optional[ExploitativeAdjustment]:
        """Adjust for passive/aggressive opponents"""

        # Passive opponent (Aggression < 1.5)
        if stats.aggression < 1.5:
            if action == PokerAction.CALL:
                return ExploitativeAdjustment(
                    adjustment_type="VALUE_BET_THINNER",
                    description="Passive opponent - bet thinner for value",
                    ev_gain=0.20,
                    risk_level="LOW"
                )

        # Aggressive opponent (Aggression > 3.0)
        elif stats.aggression > 3.0:
            if action == PokerAction.BET and game_state.bet_to_call == 0:
                return ExploitativeAdjustment(
                    adjustment_type="TRAP_MORE",
                    description="Aggressive opponent - check to induce bluffs",
                    ev_gain=0.18,
                    risk_level="MEDIUM"
                )

        return None

    def _adjust_for_fold_tendency(
        self,
        action: PokerAction,
        amount: Optional[float],
        stats: OpponentStats,
        game_state: GameState
    ) -> Optional[ExploitativeAdjustment]:
        """Adjust based on opponent fold rates"""

        # Opponent folds to c-bet too much (> 60%)
        if stats.fold_to_cbet > 60:
            if game_state.street.value in ['flop', 'turn']:
                return ExploitativeAdjustment(
                    adjustment_type="INCREASE_BLUFF_FREQUENCY",
                    description=f"Opponent folds {stats.fold_to_cbet:.0f}% to c-bets - bluff more",
                    ev_gain=0.30,
                    risk_level="LOW"
                )

        # Opponent never folds (< 30%)
        elif stats.fold_to_cbet < 30:
            if action == PokerAction.BET:
                return ExploitativeAdjustment(
                    adjustment_type="REDUCE_BLUFF_FREQUENCY",
                    description=f"Opponent rarely folds ({stats.fold_to_cbet:.0f}%) - value bet only",
                    ev_gain=0.22,
                    risk_level="LOW"
                )

        # Opponent folds to 3-bets too much (> 70%)
        if stats.fold_to_threebet > 70:
            if game_state.bet_to_call > 0:
                return ExploitativeAdjustment(
                    adjustment_type="INCREASE_3BET_FREQUENCY",
                    description=f"Opponent folds {stats.fold_to_threebet:.0f}% to 3-bets",
                    ev_gain=0.35,
                    risk_level="MEDIUM"
                )

        return None

    def calculate_exploitation_score(
        self,
        opponent_stats: OpponentStats
    ) -> Dict[str, float]:
        """
        Calculate how exploitable an opponent is

        Args:
            opponent_stats: Opponent statistics

        Returns:
            Dictionary with exploitation scores by category
        """
        scores = {
            'tightness_exploit': 0.0,
            'aggression_exploit': 0.0,
            'fold_tendency_exploit': 0.0,
            'overall_exploitability': 0.0
        }

        # Tightness score (further from 25% VPIP = more exploitable)
        vpip_deviation = abs(opponent_stats.vpip - 25) / 25
        scores['tightness_exploit'] = min(1.0, vpip_deviation)

        # Aggression score (further from 2.0 = more exploitable)
        agg_deviation = abs(opponent_stats.aggression - 2.0) / 2.0
        scores['aggression_exploit'] = min(1.0, agg_deviation)

        # Fold tendency score
        if opponent_stats.fold_to_cbet > 60:
            scores['fold_tendency_exploit'] = (opponent_stats.fold_to_cbet - 60) / 40
        elif opponent_stats.fold_to_cbet < 40:
            scores['fold_tendency_exploit'] = (40 - opponent_stats.fold_to_cbet) / 40

        # Overall (average of all scores)
        scores['overall_exploitability'] = (
            scores['tightness_exploit'] +
            scores['aggression_exploit'] +
            scores['fold_tendency_exploit']
        ) / 3

        return scores
