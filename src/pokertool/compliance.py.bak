# POKERTOOL-HEADER-START
# ---
# schema: pokerheader.v1
# project: pokertool
# file: src/pokertool/compliance.py
# version: v28.0.0
# last_commit: '2025-09-23T08:41:38+01:00'
# fixes:
# - date: '2025-09-25'
#   summary: Enhanced enterprise documentation and comprehensive unit tests added
# ---
# POKERTOOL-HEADER-END
"""
Legal Compliance Framework
Handles legal compliance requirements for poker tools including GDPR,
user consent mechanisms, data retention policies, and ToS compliance.
"""

import logging
import json
from typing import Dict, Any, List, Optional, Set
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path

logger = logging.getLogger(__name__)

class ConsentType(Enum):
    """Types of user consent required."""
    DATA_PROCESSING = "data_processing"
    ANALYTICS = "analytics" 
    MARKETING = "marketing"
    SCREEN_SCRAPING = "screen_scraping"
    HUD_OVERLAY = "hud_overlay"
    OPPONENT_MODELING = "opponent_modeling"

class DataCategory(Enum):
    """Categories of data for GDPR compliance."""
    PERSONAL = "personal"
    GAMEPLAY = "gameplay" 
    FINANCIAL = "financial"
    TECHNICAL = "technical"
    BEHAVIORAL = "behavioral"

@dataclass
class UserConsent:
    """User consent record."""
    user_id: str
    consent_type: ConsentType
    granted: bool
    timestamp: datetime = field(default_factory=datetime.utcnow)
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    version: str = "1.0"

@dataclass
class DataRetentionPolicy:
    """Data retention policy configuration."""
    category: DataCategory
    retention_days: int
    auto_delete: bool = True
    requires_consent: bool = True
    description: str = ""

@dataclass
class ComplianceViolation:
    """Compliance violation record."""
    violation_id: str
    violation_type: str
    description: str
    severity: str  # LOW, MEDIUM, HIGH, CRITICAL
    detected_at: datetime = field(default_factory=datetime.utcnow)
    resolved: bool = False
    resolution_notes: str = ""

class PokerSiteCompliance:
    """Compliance checker for poker site Terms of Service."""
    
    def __init__(self):
        self.site_policies = {
            'pokerstars': {
                'allows_hud': False,
                'allows_tracking': True,
                'allows_notes': True,
                'max_tables': 24,
                'restricted_features': ['real_time_advice', 'automated_play'],
                'last_updated': '2024-01-01'
            },
            '888poker': {
                'allows_hud': False,
                'allows_tracking': True, 
                'allows_notes': True,
                'max_tables': 16,
                'restricted_features': ['real_time_advice', 'automated_play', 'ocr'],
                'last_updated': '2024-01-01'
            },
            'partypoker': {
                'allows_hud': True,
                'allows_tracking': True,
                'allows_notes': True,
                'max_tables': 12,
                'restricted_features': ['automated_play'],
                'last_updated': '2024-01-01'
            },
            'generic': {
                'allows_hud': True,
                'allows_tracking': True,
                'allows_notes': True,
                'max_tables': 999,
                'restricted_features': [],
                'last_updated': '2024-01-01'
            }
        }
    
    def check_feature_compliance(self, site: str, feature: str) -> bool:
        """Check if a feature is compliant with site ToS."""
        site_lower = site.lower()
        if site_lower not in self.site_policies:
            logger.warning(f"No compliance data for site: {site}")
            return False
        
        policy = self.site_policies[site_lower]
        
        # Check specific feature allowances
        if feature == 'hud' and not policy.get('allows_hud', False):
            return False
        if feature == 'tracking' and not policy.get('allows_tracking', False):
            return False
        if feature == 'notes' and not policy.get('allows_notes', False):
            return False
        
        # Check restricted features
        if feature in policy.get('restricted_features', []):
            return False
        
        return True
    
    def get_site_restrictions(self, site: str) -> Dict[str, Any]:
        """Get all restrictions for a site."""
        site_lower = site.lower()
        return self.site_policies.get(site_lower, {})

class GDPRCompliance:
    """GDPR compliance management."""
    
    def __init__(self):
        self.consent_records: Dict[str, List[UserConsent]] = {}
        self.data_retention_policies = self._create_default_retention_policies()
        self.data_processing_log: List[Dict[str, Any]] = []
    
    def _create_default_retention_policies(self) -> Dict[DataCategory, DataRetentionPolicy]:
        """Create default data retention policies."""
        return {
            DataCategory.PERSONAL: DataRetentionPolicy(
                category=DataCategory.PERSONAL,
                retention_days=2555,  # 7 years for financial records
                requires_consent=True,
                description="Personal identification and contact information"
            ),
            DataCategory.GAMEPLAY: DataRetentionPolicy(
                category=DataCategory.GAMEPLAY,
                retention_days=1095,  # 3 years
                requires_consent=True,
                description="Hand histories, gameplay statistics, and analysis data"
            ),
            DataCategory.FINANCIAL: DataRetentionPolicy(
                category=DataCategory.FINANCIAL,
                retention_days=2555,  # 7 years (regulatory requirement)
                requires_consent=True,
                description="Bankroll tracking, transaction data"
            ),
            DataCategory.TECHNICAL: DataRetentionPolicy(
                category=DataCategory.TECHNICAL,
                retention_days=365,  # 1 year
                requires_consent=False,
                description="Technical logs, performance metrics, error reports"
            ),
            DataCategory.BEHAVIORAL: DataRetentionPolicy(
                category=DataCategory.BEHAVIORAL,
                retention_days=730,  # 2 years
                requires_consent=True,
                description="User behavior patterns, preferences, usage analytics"
            )
        }
    
    def record_consent(self, user_id: str, consent_type: ConsentType, 
                      granted: bool, ip_address: str = None, 
                      user_agent: str = None) -> UserConsent:
        """Record user consent."""
        consent = UserConsent(
            user_id=user_id,
            consent_type=consent_type,
            granted=granted,
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        if user_id not in self.consent_records:
            self.consent_records[user_id] = []
        
        self.consent_records[user_id].append(consent)
        
        logger.info(f"Consent recorded: {user_id} - {consent_type.value}: {granted}")
        return consent
    
    def check_consent(self, user_id: str, consent_type: ConsentType) -> bool:
        """Check if user has granted specific consent."""
        if user_id not in self.consent_records:
            return False
        
        # Get most recent consent for this type
        relevant_consents = [
            c for c in self.consent_records[user_id] 
            if c.consent_type == consent_type
        ]
        
        if not relevant_consents:
            return False
        
        # Return most recent consent
        latest_consent = max(relevant_consents, key=lambda c: c.timestamp)
        return latest_consent.granted
    
    def get_user_consents(self, user_id: str) -> List[UserConsent]:
        """Get all consent records for a user."""
        return self.consent_records.get(user_id, [])
    
    def revoke_consent(self, user_id: str, consent_type: ConsentType) -> bool:
        """Revoke user consent."""
        return self.record_consent(user_id, consent_type, False)
    
    def log_data_processing(self, user_id: str, data_category: DataCategory, 
                           purpose: str, legal_basis: str):
        """Log data processing activity for GDPR compliance."""
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'user_id': user_id,
            'data_category': data_category.value,
            'purpose': purpose,
            'legal_basis': legal_basis
        }
        
        self.data_processing_log.append(log_entry)
        
        # Keep only recent logs (last 3 years)
        cutoff_date = datetime.utcnow() - timedelta(days=1095)
        self.data_processing_log = [
            entry for entry in self.data_processing_log
            if datetime.fromisoformat(entry['timestamp']) > cutoff_date
        ]
    
    def should_delete_data(self, data_timestamp: datetime, 
                          data_category: DataCategory) -> bool:
        """Check if data should be deleted based on retention policy."""
        policy = self.data_retention_policies.get(data_category)
        if not policy:
            return False
        
        retention_period = timedelta(days=policy.retention_days)
        return datetime.utcnow() - data_timestamp > retention_period
    
    def generate_privacy_report(self, user_id: str) -> Dict[str, Any]:
        """Generate privacy report for user (GDPR Article 15)."""
        consents = self.get_user_consents(user_id)
        processing_logs = [
            log for log in self.data_processing_log 
            if log['user_id'] == user_id
        ]
        
        return {
            'user_id': user_id,
            'report_generated': datetime.utcnow().isoformat(),
            'consents': [
                {
                    'type': c.consent_type.value,
                    'granted': c.granted,
                    'timestamp': c.timestamp.isoformat(),
                    'version': c.version
                }
                for c in consents
            ],
            'data_processing': processing_logs,
            'retention_policies': {
                cat.value: {
                    'retention_days': policy.retention_days,
                    'description': policy.description
                }
                for cat, policy in self.data_retention_policies.items()
            }
        }

class ComplianceManager:
    """Main compliance management system."""
    
    def __init__(self):
        self.gdpr = GDPRCompliance()
        self.poker_sites = PokerSiteCompliance()
        self.violations: List[ComplianceViolation] = []
        self.compliance_checks_enabled = True
    
    def validate_feature_use(self, user_id: str, site: str, feature: str) -> bool:
        """Validate if user can use a feature on a specific site."""
        if not self.compliance_checks_enabled:
            return True
        
        # Check site ToS compliance
        if not self.poker_sites.check_feature_compliance(site, feature):
            self._record_violation(
                f"Feature '{feature}' not allowed on {site}",
                "SITE_TOS_VIOLATION",
                "HIGH"
            )
            return False
        
        # Check GDPR consent
        consent_mapping = {
            'hud': ConsentType.HUD_OVERLAY,
            'tracking': ConsentType.DATA_PROCESSING,
            'screen_scraping': ConsentType.SCREEN_SCRAPING,
            'opponent_modeling': ConsentType.OPPONENT_MODELING
        }
        
        required_consent = consent_mapping.get(feature)
        if required_consent and not self.gdpr.check_consent(user_id, required_consent):
            self._record_violation(
                f"User {user_id} lacks consent for {feature}",
                "GDPR_CONSENT_VIOLATION", 
                "MEDIUM"
            )
            return False
        
        return True
    
    def _record_violation(self, description: str, violation_type: str, severity: str):
        """Record a compliance violation."""
        violation = ComplianceViolation(
            violation_id=f"V{int(datetime.utcnow().timestamp())}",
            violation_type=violation_type,
            description=description,
            severity=severity
        )
        
        self.violations.append(violation)
        logger.warning(f"Compliance violation: {description}")
    
    def setup_user_consent(self, user_id: str, ip_address: str = None, 
                          user_agent: str = None) -> Dict[str, bool]:
        """Setup initial consent for new user."""
        # Record essential consents
        essential_consents = {
            ConsentType.DATA_PROCESSING: False,  # User must explicitly consent
            ConsentType.ANALYTICS: False,
            ConsentType.SCREEN_SCRAPING: False,
            ConsentType.HUD_OVERLAY: False,
            ConsentType.OPPONENT_MODELING: False,
            ConsentType.MARKETING: False
        }
        
        results = {}
        for consent_type, default_value in essential_consents.items():
            consent = self.gdpr.record_consent(
                user_id, consent_type, default_value, ip_address, user_agent
            )
            results[consent_type.value] = consent.granted
        
        return results
    
    def get_required_consents(self) -> List[Dict[str, Any]]:
        """Get list of required consents for UI display."""
        return [
            {
                'type': ConsentType.DATA_PROCESSING.value,
                'title': 'Data Processing',
                'description': 'Process your gameplay data for hand analysis and statistics',
                'required': True
            },
            {
                'type': ConsentType.SCREEN_SCRAPING.value,
                'title': 'Screen Scraping',
                'description': 'Capture table information for real-time analysis',
                'required': False
            },
            {
                'type': ConsentType.HUD_OVERLAY.value,
                'title': 'HUD Overlay',
                'description': 'Display real-time statistics overlay on poker tables',
                'required': False
            },
            {
                'type': ConsentType.OPPONENT_MODELING.value,
                'title': 'Opponent Modeling',
                'description': 'Analyze opponent behavior patterns and tendencies',
                'required': False
            },
            {
                'type': ConsentType.ANALYTICS.value,
                'title': 'Usage Analytics',
                'description': 'Collect anonymous usage data to improve the application',
                'required': False
            },
            {
                'type': ConsentType.MARKETING.value,
                'title': 'Marketing Communications',
                'description': 'Receive updates about new features and promotions',
                'required': False
            }
        ]
    
    def generate_privacy_policy(self) -> str:
        """Generate privacy policy text."""
        return """
PRIVACY POLICY

Last updated: {date}

1. DATA COLLECTION
We collect the following types of data:
- Personal information (username, email)
- Gameplay data (hand histories, statistics)
- Technical data (logs, performance metrics)
- Behavioral data (usage patterns, preferences)

2. DATA USE
Your data is used for:
- Providing poker analysis and statistics
- Improving our services
- Complying with legal obligations
- With your consent, for marketing communications

3. DATA RETENTION
- Personal data: 7 years
- Gameplay data: 3 years  
- Technical data: 1 year
- Behavioral data: 2 years

4. YOUR RIGHTS (GDPR)
You have the right to:
- Access your personal data
- Rectify inaccurate data
- Erase your personal data
- Restrict processing
- Data portability
- Object to processing
- Withdraw consent

5. CONTACT
For privacy questions, contact: privacy@pokertool.com
        """.format(date=datetime.utcnow().strftime("%B %d, %Y"))
    
    def cleanup_expired_data(self) -> Dict[str, int]:
        """Clean up expired data based on retention policies."""
        # This would integrate with the database to actually delete expired data
        # For now, return a summary of what would be cleaned up
        
        cleanup_summary = {
            'personal_data_records': 0,
            'gameplay_records': 0, 
            'technical_logs': 0,
            'behavioral_data': 0
        }
        
        logger.info(f"Data cleanup completed: {cleanup_summary}")
        return cleanup_summary
    
    def get_compliance_status(self) -> Dict[str, Any]:
        """Get overall compliance status."""
        recent_violations = [
            v for v in self.violations 
            if datetime.utcnow() - v.detected_at < timedelta(days=30)
        ]
        
        return {
            'gdpr_compliant': len(recent_violations) == 0,
            'recent_violations': len(recent_violations),
            'total_violations': len(self.violations),
            'consent_records': sum(len(consents) for consents in self.gdpr.consent_records.values()),
            'supported_sites': len(self.poker_sites.site_policies),
            'last_updated': datetime.utcnow().isoformat()
        }

# Global compliance manager instance
_compliance_manager: Optional[ComplianceManager] = None

def get_compliance_manager() -> ComplianceManager:
    """Get the global compliance manager instance."""
    global _compliance_manager
    if _compliance_manager is None:
        _compliance_manager = ComplianceManager()
    return _compliance_manager

def check_feature_compliance(user_id: str, site: str, feature: str) -> bool:
    """Check if a feature can be used compliantly."""
    manager = get_compliance_manager()
    return manager.validate_feature_use(user_id, site, feature)

def record_user_consent(user_id: str, consent_type: str, granted: bool, 
                       ip_address: str = None, user_agent: str = None) -> bool:
    """Record user consent for GDPR compliance."""
    try:
        manager = get_compliance_manager()
        consent_enum = ConsentType(consent_type)
        manager.gdpr.record_consent(user_id, consent_enum, granted, ip_address, user_agent)
        return True
    except ValueError:
        logger.error(f"Invalid consent type: {consent_type}")
        return False

def get_user_privacy_report(user_id: str) -> Dict[str, Any]:
    """Generate GDPR privacy report for user."""
    manager = get_compliance_manager()
    return manager.gdpr.generate_privacy_report(user_id)

def is_site_compliant(site: str, feature: str) -> bool:
    """Check if feature is compliant with poker site ToS."""
    manager = get_compliance_manager()
    return manager.poker_sites.check_feature_compliance(site, feature)

if __name__ == '__main__':
    # Test compliance system
    manager = get_compliance_manager()
    
    # Test user consent
    user_id = "test_user"
    manager.setup_user_consent(user_id, "127.0.0.1", "TestAgent/1.0")
    
    # Test feature compliance
    print(f"HUD on PokerStars: {manager.validate_feature_use(user_id, 'pokerstars', 'hud')}")
    print(f"HUD on PartyPoker: {manager.validate_feature_use(user_id, 'partypoker', 'hud')}")
    
    # Test privacy report
    report = manager.gdpr.generate_privacy_report(user_id)
    print(f"Privacy report: {json.dumps(report, indent=2)}")
    
    # Test compliance status
    status = manager.get_compliance_status()
    print(f"Compliance status: {json.dumps(status, indent=2)}")
    
    print("Compliance system test completed!")
