# POKERTOOL-HEADER-START
# ---
# schema: pokerheader.v1
# project: pokertool
# file: src/pokertool/bankroll_management.py
# version: v28.0.0
# last_commit: '2025-09-23T08:41:38+01:00'
# fixes:
# - date: '2025-09-25'
#   summary: Enhanced enterprise documentation and comprehensive unit tests added
# ---
# POKERTOOL-HEADER-END
"""
Bankroll Management Module
Provides comprehensive bankroll tracking, Kelly criterion calculations,
variance analysis, and risk management for poker players.
"""

import logging
import json
import math
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum
import statistics

logger = logging.getLogger(__name__)

class GameType(Enum):
    """Types of poker games."""
    CASH_GAME = "cash_game"
    SIT_N_GO = "sit_n_go"
    TOURNAMENT = "tournament"
    SPIN_N_GO = "spin_n_go"

class StakeLevel(Enum):
    """Stake levels for games."""
    MICRO = "micro"      # $0.01/$0.02 - $0.05/$0.10
    LOW = "low"          # $0.10/$0.25 - $0.50/$1.00
    MID = "mid"          # $1/$2 - $5/$10
    HIGH = "high"        # $10/$25+
    NOSEBLEEDS = "nosebleeds"  # $200/$400+

@dataclass
class BankrollTransaction:
    """Individual bankroll transaction."""
    transaction_id: str
    timestamp: datetime = field(default_factory=datetime.utcnow)
    game_type: GameType = GameType.CASH_GAME
    stake_level: str = "0.05/0.10"
    buy_in: float = 0.0
    cash_out: float = 0.0
    profit_loss: float = 0.0
    session_length: timedelta = field(default_factory=lambda: timedelta(hours=1))
    notes: str = ""
    location: str = ""  # Online site or live casino
    
    def get_roi(self) -> float:
        """Calculate return on investment."""
        if self.buy_in == 0:
            return 0.0
        return (self.profit_loss / self.buy_in) * 100

@dataclass
class BankrollSnapshot:
    """Snapshot of bankroll at a point in time."""
    timestamp: datetime = field(default_factory=datetime.utcnow)
    total_bankroll: float = 0.0
    available_bankroll: float = 0.0  # After accounting for locked funds
    peak_bankroll: float = 0.0
    total_profit_loss: float = 0.0
    sessions_played: int = 0
    total_volume: float = 0.0  # Total buy-ins
    
    def get_roi(self) -> float:
        """Calculate overall ROI."""
        if self.total_volume == 0:
            return 0.0
        return (self.total_profit_loss / self.total_volume) * 100

class KellyCriterion:
    """Kelly Criterion calculator for optimal bankroll sizing."""
    
    @staticmethod
    def calculate_kelly_fraction(win_rate: float, avg_win: float, avg_loss: float) -> float:
        """
        Calculate Kelly fraction for optimal bet sizing.
        
        Args:
            win_rate: Probability of winning (0-1)
            avg_win: Average win amount
            avg_loss: Average loss amount (positive number)
            
        Returns:
            Kelly fraction (0-1)
        """
        if win_rate <= 0 or win_rate >= 1 or avg_win <= 0 or avg_loss <= 0:
            return 0.0
        
        # Kelly formula: f = (bp - q) / b
        # where b = odds received on wager, p = probability of winning, q = probability of losing
        b = avg_win / avg_loss  # Odds
        q = 1 - win_rate
        
        kelly_fraction = (b * win_rate - q) / b
        
        # Cap at 25% for safety
        return min(max(kelly_fraction, 0.0), 0.25)
    
    @staticmethod
    def recommended_stake(bankroll: float, kelly_fraction: float, game_buy_in: float) -> Tuple[float, str]:
        """
        Recommend stake based on Kelly criterion.
        
        Returns:
            Tuple of (max_buy_in, recommendation_text)
        """
        if kelly_fraction <= 0:
            return 0.0, "Not recommended to play - negative edge"
        
        max_buy_in = bankroll * kelly_fraction
        
        if max_buy_in < game_buy_in:
            return max_buy_in, f"Bankroll too small - max buy-in: ${max_buy_in:.2f}"
        
        num_buy_ins = max_buy_in / game_buy_in
        
        if num_buy_ins >= 40:
            return max_buy_in, "Conservative - excellent bankroll management"
        elif num_buy_ins >= 20:
            return max_buy_in, "Moderate risk - good bankroll management"
        elif num_buy_ins >= 10:
            return max_buy_in, "High risk - consider moving down stakes"
        else:
            return max_buy_in, "Very high risk - strongly consider lower stakes"

class VarianceCalculator:
    """Calculate variance and risk metrics."""
    
    @staticmethod
    def calculate_standard_deviation(results: List[float]) -> float:
        """Calculate standard deviation of results."""
        if len(results) < 2:
            return 0.0
        return statistics.stdev(results)
    
    @staticmethod
    def calculate_downswing_probability(win_rate: float, std_dev: float, 
                                      sessions: int, downswing_amount: float) -> float:
        """
        Calculate probability of experiencing a downswing.
        
        Args:
            win_rate: Expected win rate per session
            std_dev: Standard deviation of results
            sessions: Number of sessions
            downswing_amount: Size of downswing to calculate probability for
            
        Returns:
            Probability (0-1) of experiencing the downswing
        """
        if std_dev == 0 or sessions == 0:
            return 0.0
        
        expected_total = win_rate * sessions
        variance_total = std_dev ** 2 * sessions
        
        # Using normal approximation
        z_score = (downswing_amount - expected_total) / math.sqrt(variance_total)
        
        # Probability of being below the downswing threshold
        # This is a simplified approximation
        return max(0.0, min(1.0, 0.5 * (1 + math.erf(z_score / math.sqrt(2)))))
    
    @staticmethod
    def risk_of_ruin(bankroll: float, win_rate: float, std_dev: float, 
                     ruin_threshold: float = 0.0) -> float:
        """
        Calculate risk of ruin (bankroll falling below threshold).
        
        Args:
            bankroll: Current bankroll
            win_rate: Expected win rate per unit
            std_dev: Standard deviation
            ruin_threshold: Threshold below which is considered "ruin"
            
        Returns:
            Probability of ruin (0-1)
        """
        if win_rate <= 0 or std_dev <= 0:
            return 1.0 if bankroll <= ruin_threshold else 0.0
        
        # Simplified risk of ruin calculation
        # In practice, this would use more sophisticated models
        distance_to_ruin = bankroll - ruin_threshold
        if distance_to_ruin <= 0:
            return 1.0
        
        # Approximate calculation based on Gaussian distribution
        z_score = distance_to_ruin / (std_dev * math.sqrt(100))  # Assuming 100 sessions
        risk = 0.5 * (1 - math.erf(z_score / math.sqrt(2)))
        
        return max(0.0, min(1.0, risk))

class BankrollAlert:
    """Bankroll alert system."""
    
    def __init__(self, bankroll_manager):
        self.bankroll_manager = bankroll_manager
        self.alerts: List[Dict[str, Any]] = []
    
    def check_alerts(self) -> List[Dict[str, Any]]:
        """Check for bankroll alerts."""
        alerts = []
        snapshot = self.bankroll_manager.get_current_snapshot()
        
        # Bankroll drop alerts
        if snapshot.peak_bankroll > 0:
            drop_percentage = (snapshot.peak_bankroll - snapshot.total_bankroll) / snapshot.peak_bankroll
            
            if drop_percentage >= 0.5:
                alerts.append({
                    'type': 'SEVERE_DOWNSWING',
                    'severity': 'CRITICAL',
                    'message': f'Bankroll down {drop_percentage:.1%} from peak',
                    'recommendation': 'Consider moving down stakes significantly'
                })
            elif drop_percentage >= 0.3:
                alerts.append({
                    'type': 'MAJOR_DOWNSWING',
                    'severity': 'HIGH',
                    'message': f'Bankroll down {drop_percentage:.1%} from peak',
                    'recommendation': 'Consider moving down stakes'
                })
            elif drop_percentage >= 0.2:
                alerts.append({
                    'type': 'MODERATE_DOWNSWING',
                    'severity': 'MEDIUM',
                    'message': f'Bankroll down {drop_percentage:.1%} from peak',
                    'recommendation': 'Monitor closely and consider stake reduction'
                })
        
        # Low bankroll alerts
        recent_transactions = self.bankroll_manager.get_recent_transactions(30)  # Last 30 days
        if recent_transactions:
            avg_buy_in = sum(t.buy_in for t in recent_transactions) / len(recent_transactions)
            buy_ins_remaining = snapshot.available_bankroll / avg_buy_in if avg_buy_in > 0 else 0
            
            if buy_ins_remaining < 10:
                alerts.append({
                    'type': 'LOW_BANKROLL',
                    'severity': 'CRITICAL',
                    'message': f'Only {buy_ins_remaining:.1f} buy-ins remaining',
                    'recommendation': 'Move down stakes immediately or reload bankroll'
                })
            elif buy_ins_remaining < 20:
                alerts.append({
                    'type': 'LOW_BANKROLL',
                    'severity': 'HIGH',
                    'message': f'Only {buy_ins_remaining:.1f} buy-ins remaining',
                    'recommendation': 'Consider moving down stakes'
                })
        
        # Winning streak alerts (move up?)
        if len(recent_transactions) >= 10:
            recent_results = [t.profit_loss for t in recent_transactions[-10:]]
            if all(r >= 0 for r in recent_results[-5:]) and sum(recent_results) > 0:
                alerts.append({
                    'type': 'WINNING_STREAK',
                    'severity': 'INFO',
                    'message': 'On a winning streak - consider moving up stakes',
                    'recommendation': 'Evaluate if bankroll supports higher stakes'
                })
        
        return alerts

class BankrollManager:
    """Main bankroll management system."""
    
    def __init__(self):
        self.transactions: List[BankrollTransaction] = []
        self.snapshots: List[BankrollSnapshot] = []
        self.alerts_system = BankrollAlert(self)
        self.initial_bankroll = 0.0
        
    def set_initial_bankroll(self, amount: float):
        """Set initial bankroll amount."""
        self.initial_bankroll = amount
        
        # Create initial snapshot
        snapshot = BankrollSnapshot(
            total_bankroll=amount,
            available_bankroll=amount,
            peak_bankroll=amount
        )
        self.snapshots.append(snapshot)
        
        logger.info(f"Initial bankroll set to ${amount:.2f}")
    
    def add_transaction(self, transaction: BankrollTransaction) -> bool:
        """Add a new bankroll transaction."""
        try:
            # Calculate profit/loss if not provided
            if transaction.profit_loss == 0.0:
                transaction.profit_loss = transaction.cash_out - transaction.buy_in
            
            self.transactions.append(transaction)
            
            # Update snapshot
            self._update_snapshot()
            
            logger.info(f"Transaction added: {transaction.profit_loss:+.2f} "
                       f"({transaction.game_type.value} {transaction.stake_level})")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to add transaction: {e}")
            return False
    
    def _update_snapshot(self):
        """Update current bankroll snapshot."""
        total_pl = sum(t.profit_loss for t in self.transactions)
        current_bankroll = self.initial_bankroll + total_pl
        
        # Calculate peak
        peak_bankroll = self.initial_bankroll
        running_total = self.initial_bankroll
        for transaction in self.transactions:
            running_total += transaction.profit_loss
            peak_bankroll = max(peak_bankroll, running_total)
        
        # Calculate total volume
        total_volume = sum(t.buy_in for t in self.transactions)
        
        snapshot = BankrollSnapshot(
            total_bankroll=current_bankroll,
            available_bankroll=current_bankroll,  # Simplified - assume all available
            peak_bankroll=peak_bankroll,
            total_profit_loss=total_pl,
            sessions_played=len(self.transactions),
            total_volume=total_volume
        )
        
        # Replace last snapshot or add new one
        if self.snapshots:
            self.snapshots[-1] = snapshot
        else:
            self.snapshots.append(snapshot)
    
    def get_current_snapshot(self) -> BankrollSnapshot:
        """Get current bankroll snapshot."""
        if not self.snapshots:
            return BankrollSnapshot()
        return self.snapshots[-1]
    
    def get_recent_transactions(self, days: int = 30) -> List[BankrollTransaction]:
        """Get transactions from the last N days."""
        cutoff_date = datetime.utcnow() - timedelta(days=days)
        return [t for t in self.transactions if t.timestamp >= cutoff_date]
    
    def calculate_statistics(self, days: int = 30) -> Dict[str, Any]:
        """Calculate bankroll statistics."""
        recent_transactions = self.get_recent_transactions(days)
        
        if not recent_transactions:
            return {
                'period_days': days,
                'sessions_played': 0,
                'total_profit_loss': 0.0,
                'avg_session_result': 0.0,
                'win_rate': 0.0,
                'roi': 0.0,
                'hourly_rate': 0.0,
                'std_deviation': 0.0,
                'best_session': 0.0,
                'worst_session': 0.0
            }
        
        results = [t.profit_loss for t in recent_transactions]
        winning_sessions = [r for r in results if r > 0]
        
        total_hours = sum(t.session_length.total_seconds() / 3600 for t in recent_transactions)
        total_volume = sum(t.buy_in for t in recent_transactions)
        
        return {
            'period_days': days,
            'sessions_played': len(recent_transactions),
            'total_profit_loss': sum(results),
            'avg_session_result': statistics.mean(results),
            'win_rate': len(winning_sessions) / len(results),
            'roi': (sum(results) / total_volume * 100) if total_volume > 0 else 0.0,
            'hourly_rate': sum(results) / total_hours if total_hours > 0 else 0.0,
            'std_deviation': VarianceCalculator.calculate_standard_deviation(results),
            'best_session': max(results),
            'worst_session': min(results),
            'total_hours': total_hours,
            'total_volume': total_volume
        }
    
    def get_kelly_recommendation(self, stake_buy_in: float, days: int = 90) -> Dict[str, Any]:
        """Get Kelly criterion recommendation for a stake level."""
        stats = self.calculate_statistics(days)
        
        if stats['sessions_played'] < 10:
            return {
                'recommendation': 'Insufficient data - need at least 10 sessions',
                'kelly_fraction': 0.0,
                'max_buy_in': 0.0,
                'risk_level': 'UNKNOWN'
            }
        
        # Calculate Kelly inputs
        win_rate = stats['win_rate']
        
        # Calculate average win and loss
        recent_transactions = self.get_recent_transactions(days)
        winning_results = [t.profit_loss for t in recent_transactions if t.profit_loss > 0]
        losing_results = [-t.profit_loss for t in recent_transactions if t.profit_loss < 0]
        
        if not winning_results or not losing_results:
            return {
                'recommendation': 'Need both winning and losing sessions for calculation',
                'kelly_fraction': 0.0,
                'max_buy_in': 0.0,
                'risk_level': 'UNKNOWN'
            }
        
        avg_win = statistics.mean(winning_results)
        avg_loss = statistics.mean(losing_results)
        
        kelly_fraction = KellyCriterion.calculate_kelly_fraction(win_rate, avg_win, avg_loss)
        current_bankroll = self.get_current_snapshot().available_bankroll
        
        max_buy_in, recommendation = KellyCriterion.recommended_stake(
            current_bankroll, kelly_fraction, stake_buy_in
        )
        
        return {
            'kelly_fraction': kelly_fraction,
            'max_buy_in': max_buy_in,
            'recommendation': recommendation,
            'current_bankroll': current_bankroll,
            'risk_level': 'LOW' if kelly_fraction < 0.05 else 'MEDIUM' if kelly_fraction < 0.15 else 'HIGH',
            'win_rate': win_rate,
            'avg_win': avg_win,
            'avg_loss': avg_loss
        }
    
    def get_variance_analysis(self, days: int = 90) -> Dict[str, Any]:
        """Get variance and risk analysis."""
        stats = self.calculate_statistics(days)
        current_snapshot = self.get_current_snapshot()
        
        if stats['sessions_played'] < 5:
            return {'error': 'Insufficient data for variance analysis'}
        
        # Risk of ruin calculation
        risk_of_ruin = VarianceCalculator.risk_of_ruin(
            current_snapshot.available_bankroll,
            stats['avg_session_result'],
            stats['std_deviation']
        )
        
        # Downswing probability
        downswing_prob_20 = VarianceCalculator.calculate_downswing_probability(
            stats['avg_session_result'], stats['std_deviation'], 
            100, -current_snapshot.available_bankroll * 0.2
        )
        
        downswing_prob_50 = VarianceCalculator.calculate_downswing_probability(
            stats['avg_session_result'], stats['std_deviation'],
            100, -current_snapshot.available_bankroll * 0.5
        )
        
        return {
            'standard_deviation': stats['std_deviation'],
            'risk_of_ruin': risk_of_ruin,
            'downswing_probability': {
                '20_percent': downswing_prob_20,
                '50_percent': downswing_prob_50
            },
            'confidence_intervals': {
                '68_percent': {
                    'lower': stats['avg_session_result'] - stats['std_deviation'],
                    'upper': stats['avg_session_result'] + stats['std_deviation']
                },
                '95_percent': {
                    'lower': stats['avg_session_result'] - 2 * stats['std_deviation'],
                    'upper': stats['avg_session_result'] + 2 * stats['std_deviation']
                }
            }
        }
    
    def check_alerts(self) -> List[Dict[str, Any]]:
        """Check for bankroll management alerts."""
        return self.alerts_system.check_alerts()
    
    def export_data(self) -> Dict[str, Any]:
        """Export all bankroll data."""
        return {
            'initial_bankroll': self.initial_bankroll,
            'transactions': [
                {
                    'timestamp': t.timestamp.isoformat(),
                    'game_type': t.game_type.value,
                    'stake_level': t.stake_level,
                    'buy_in': t.buy_in,
                    'cash_out': t.cash_out,
                    'profit_loss': t.profit_loss,
                    'session_length_hours': t.session_length.total_seconds() / 3600,
                    'notes': t.notes,
                    'location': t.location,
                    'roi': t.get_roi()
                }
                for t in self.transactions
            ],
            'current_snapshot': {
                'timestamp': self.get_current_snapshot().timestamp.isoformat(),
                'total_bankroll': self.get_current_snapshot().total_bankroll,
                'peak_bankroll': self.get_current_snapshot().peak_bankroll,
                'total_profit_loss': self.get_current_snapshot().total_profit_loss,
                'sessions_played': self.get_current_snapshot().sessions_played,
                'roi': self.get_current_snapshot().get_roi()
            }
        }

# Global bankroll manager
_bankroll_manager: Optional[BankrollManager] = None

def get_bankroll_manager() -> BankrollManager:
    """Get the global bankroll manager instance."""
    global _bankroll_manager
    if _bankroll_manager is None:
        _bankroll_manager = BankrollManager()
    return _bankroll_manager

def add_session_result(game_type: str, stake_level: str, buy_in: float, 
                      cash_out: float, session_hours: float = 1.0,
                      location: str = "Online", notes: str = "") -> bool:
    """Add a session result to bankroll tracking."""
    manager = get_bankroll_manager()
    
    transaction = BankrollTransaction(
        transaction_id=f"session_{int(datetime.utcnow().timestamp())}",
        game_type=GameType(game_type),
        stake_level=stake_level,
        buy_in=buy_in,
        cash_out=cash_out,
        session_length=timedelta(hours=session_hours),
        location=location,
        notes=notes
    )
    
    return manager.add_transaction(transaction)

def get_bankroll_summary() -> Dict[str, Any]:
    """Get current bankroll summary."""
    manager = get_bankroll_manager()
    snapshot = manager.get_current_snapshot()
    stats = manager.calculate_statistics(30)
    
    return {
        'current_bankroll': snapshot.total_bankroll,
        'peak_bankroll': snapshot.peak_bankroll,
        'total_sessions': snapshot.sessions_played,
        'monthly_profit_loss': stats['total_profit_loss'],
        'monthly_roi': stats['roi'],
        'win_rate': stats['win_rate'],
        'hourly_rate': stats['hourly_rate']
    }

def get_stake_recommendation(stake_buy_in: float) -> Dict[str, Any]:
    """Get Kelly criterion recommendation for a stake."""
    manager = get_bankroll_manager()
    return manager.get_kelly_recommendation(stake_buy_in)

if __name__ == '__main__':
    # Test bankroll management system
    manager = get_bankroll_manager()
    
    # Set initial bankroll
    manager.set_initial_bankroll(1000.0)
    
    # Add some sample sessions
    test_sessions = [
        (GameType.CASH_GAME, "0.05/0.10", 10, 15, 2.0),  # +$5 win
        (GameType.CASH_GAME, "0.05/0.10", 10, 5, 1.5),   # -$5 loss
        (GameType.CASH_GAME, "0.05/0.10", 10, 25, 3.0),  # +$15 win
        (GameType.SIT_N_GO, "5+0.50", 5.5, 0, 0.5),      # Loss
        (GameType.SIT_N_GO, "5+0.50", 5.5, 15, 1.0),     # Win
    ]
    
    for game_type, stake, buy_in, cash_out, hours in test_sessions:
        transaction = BankrollTransaction(
            transaction_id=f"test_{len(manager.transactions)}",
            game_type=game_type,
            stake_level=stake,
            buy_in=buy_in,
            cash_out=cash_out,
            session_length=timedelta(hours=hours)
        )
        manager.add_transaction(transaction)
    
    # Test statistics
    stats = manager.calculate_statistics()
    logger.info("Bankroll Statistics:")
    logger.info(f"Current bankroll: ${manager.get_current_snapshot().total_bankroll:.2f}")
    logger.info(f"Sessions played: {stats['sessions_played']}")
    logger.info(f"Win rate: {stats['win_rate']:.2%}")
    logger.info(f"ROI: {stats['roi']:.2%}")
    logger.info(f"Hourly rate: ${stats['hourly_rate']:.2f}")
    
    # Test Kelly recommendation
    kelly_rec = manager.get_kelly_recommendation(10.0)  # $10 buy-in game
    logger.info("Kelly Recommendation for $10 game:")
    logger.info(f"Kelly fraction: {kelly_rec['kelly_fraction']:.3f}")
    logger.info(f"Max buy-in: ${kelly_rec['max_buy_in']:.2f}")
    logger.info(f"Recommendation: {kelly_rec['recommendation']}")
    
    # Test alerts
    alerts = manager.check_alerts()
    logger.info(f"Alerts: {len(alerts)}")
    for alert in alerts:
        logger.info(f"- {alert['type']}: {alert['message']}")
    
    logger.info("Bankroll management system test completed!")
